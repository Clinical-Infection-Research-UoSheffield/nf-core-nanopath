#!/usr/bin/env python

import numpy as np
import umap
import matplotlib.pyplot as plt
import pandas as pd
import hdbscan
import sys
import argparse
import logging

logger = logging.getLogger()

def parse_args():
    # Create argument parser
    parser = argparse.ArgumentParser()

    parser.add_argument("--infile", help="K-mer freqeuency file", action="store", dest="kmer_freqs")
    parser.add_argument("--umap_n_neighbors", help="The size of the local neighborhood UMAP will look at when attempting to learn the manifold structure of the data [15]", type=int, default=15)
    parser.add_argument("--umap_min_dist", help="The minimum distance apart that points are allowed to be in the low dimensional representation. [0.1]", type=float, default=0.1)
    parser.add_argument("--min_samples", help="Measure of how conservative the clustering should be. [None]", type=str, default="n")
    parser.add_argument("--min_cluster_size", help="Minimum number of reads to call a independent cluster [50]", type=int, default=50)
    parser.add_argument("--cluster_sel_epsilon", help="Minimun distance to separate clusters. [0.5]", type=float, default=0.5)
    parser.add_argument("--outfile", help="Output file name [*hdbscan.output]", type=str, default="hdbscan.output")

    # Parse arguments
    args = parser.parse_args()

    return args

def main(args):
    df = pd.read_csv(args.kmer_freqs, delimiter="\t")

    #UMAP
    motifs = [x for x in df.columns.values if x not in ["read", "length"]]
    X = df.loc[:,motifs]
    X_embedded = umap.UMAP(n_neighbors=int(args.umap_n_neighbors), min_dist=int(args.umap_min_dist), verbose=2).fit_transform(X)

    df_umap = pd.DataFrame(X_embedded, columns=["D1", "D2"])
    umap_out = pd.concat([df["read"], df["length"], df_umap], axis=1)

    if args.min_samples == "n":
        min_samp = None
    else:
        min_samp = int(args.min_samples)

    #HDBSCAN
    X = umap_out.loc[:,["D1", "D2"]]
    print(X.shape)
    if X.shape[0] == 1:
        logger.critical("Only one read was provided. HDBSCAN cannot cluster a single point.")
        sys.exit(73)
    umap_out["bin_id"] = hdbscan.HDBSCAN(min_cluster_size=int(args.min_cluster_size), cluster_selection_epsilon=int(args.cluster_sel_epsilon), min_samples=min_samp, allow_single_cluster=True).fit_predict(X)

    #PLOT
    plt.figure(figsize=(20,20))
    plt.scatter(X_embedded[:, 0], X_embedded[:, 1], c=umap_out["bin_id"], cmap='Spectral', s=1)
    plt.xlabel("UMAP1", fontsize=18)
    plt.ylabel("UMAP2", fontsize=18)
    plt.gca().set_aspect('equal', 'datalim')
    plt.title("Projecting " + str(len(umap_out['bin_id'])) + " reads. " + str(len(umap_out['bin_id'].unique())) + " clusters generated by HDBSCAN", fontsize=18)

    for cluster in np.sort(umap_out['bin_id'].unique()):
        read = umap_out.loc[umap_out['bin_id'] == cluster].iloc[0]
        plt.annotate(str(cluster), (read['D1'], read['D2']), weight='bold', size=14)

    plt.savefig(args.outfile + ".png")
    #remove reads with bin_id = -1
    umap_out_clusters = umap_out[umap_out["bin_id"] != -1]
    umap_out_clusters.to_csv(args.outfile + ".tsv", sep="\t", index=False)

if __name__=="__main__":
    args = parse_args()

    main(args)
    print("umap finished")